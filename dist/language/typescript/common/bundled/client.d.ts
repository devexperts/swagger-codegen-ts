import { either } from 'fp-ts';
export declare const clientRef: either.Either<Error, import("../../../../utils/ref").Ref<"#/client/client">>;
export declare const client = "\n\timport { HKT, Kind, Kind2, URIS, URIS2 } from 'fp-ts/lib/HKT';\n\timport { MonadThrow, MonadThrow1, MonadThrow2 } from 'fp-ts/lib/MonadThrow';\n\timport { Errors } from 'io-ts';\n\timport { PathReporter } from 'io-ts/lib/PathReporter';\n\timport { left } from 'fp-ts/lib/Either';\n\n\texport interface Request {\n\t\treadonly method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';\n\t\treadonly url: string;\n\t\treadonly responseType: 'json' | 'blob' | 'text';\n\t\treadonly query?: string;\n\t\treadonly body?: unknown;\n\t\treadonly headers?: Record<string, unknown>;\n\t}\n\n\texport interface HTTPClient<F> extends MonadThrow<F> {\n\t\treadonly request: (request: Request) => HKT<F, unknown>;\n\t}\n\texport interface HTTPClient1<F extends URIS> extends MonadThrow1<F> {\n\t\treadonly request: (request: Request) => Kind<F, unknown>;\n\t}\n\texport interface HTTPClient2<F extends URIS2> extends MonadThrow2<F> {\n\t\treadonly request: (request: Request) => Kind2<F, unknown, unknown>;\n\t}\n\n\texport interface WebSocketChannelRequest {\n\t\treadonly method: 'GET' | 'POST';\n\t\treadonly channel: string;\n\t\treadonly query?: Record<string, unknown>;\n\t\treadonly headers?: Record<string, unknown>;\n\t}\n\n\texport interface WebSocketClient2<F extends URIS2> {\n\t\treadonly channel: (request: WebSocketChannelRequest) => WebSocketChannel2<F>;\n\t}\n\texport interface WebSocketClient1<F extends URIS> {\n\t\treadonly channel: (request: WebSocketChannelRequest) => WebSocketChannel1<F>;\n\t}\n\texport interface WebSocketClient<F> {\n\t\treadonly channel: (request: WebSocketChannelRequest) => WebSocketChannel<F>;\n\t}\n\n\texport interface WebSocketChannel<F> extends MonadThrow<F> {\n\t\treadonly send: (payload: unknown) => void;\n\t\treadonly message: HKT<F, unknown>\n\t}\n\texport interface WebSocketChannel1<F extends URIS> extends MonadThrow1<F> {\n\t\treadonly send: (payload: unknown) => void;\n\t\treadonly message: Kind<F, unknown>\n\t}\n\texport interface WebSocketChannel2<F extends URIS2> extends MonadThrow2<F> {\n\t\treadonly send: (payload: unknown) => void;\n\t\treadonly message: Kind2<F, unknown, unknown>\n\t}\n\n\texport class ResponseValidationError extends Error {\n\t\tstatic create(errors: Errors): ResponseValidationError {\n\t\t\treturn new ResponseValidationError(errors);\n\t\t}\n\n\t\tconstructor(readonly errors: Errors) {\n\t\t\tsuper(PathReporter.report(left(errors)).join('\\n\\n'));\n\t\t\tthis.name = 'ResponseValidationError';\n\t\t\tObject.setPrototypeOf(this, ResponseValidationError.prototype);\n\t\t}\n\t}\n";
export declare const clientFile: either.Either<Error, import("../../../../utils/fs").FSEntity>;
